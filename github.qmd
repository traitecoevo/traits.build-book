# Using GitHub

# Working with our GitHub repository

By far our preferred way of contributing is for you to contribute files directly into the repository and then send a  [pull request](https://help.github.com/articles/using-pull-requests/) with your input. You can do this by

- (for approved maintainers of traits.build) Creating a branch, or
- (for others) forking the database in github

In short,

1. Create a Git branch for your new work, either within the AusTraits repo (if you are an approved contributor) or as a [fork of the repo](https://help.github.com/en/github/getting-started-with-github/fork-a-repo).
2. Make commits and push these up onto the branch.
2. Make sure everything runs fine before you send a pull request.
3. When you're ready to merge in the new features,

Before you make a substantial pull request, you should always [file an issue](https://github.com/traitecoevo/traits.build/issues) and make sure someone from the team agrees that it’s worth pursuing the problem. If you’ve found a bug, create an associated issue and illustrate the bug with a minimal [reprex](https://www.tidyverse.org/help/#reprex) illustrating the issue.

If this is not possible, you could email the relevant files (see above) to the AusTraits email: austraits.database@gmail.com

## Merging a pull request

There are multiple ways to merge a pull request, including using GitHub's built-in options for merging and squashing. When merging a PR, we ideally want

- a single commit
- to attribute the work to the original author
- to run various checks along the way

There are two ways to do this. For both, you need to be an approved maintainer.

### Merging in your own PR

You can merge in your own PR after you've had someone else review it.

1. Send the PR
2. Tag someone to review
3. Once ready, merge into main choosing "Squash & Merge", using an informative commit message.


### Merging someone else's PR

When merging in someone else's PR, the built-in  options aren't ideal, as they either take all of the commits on a branch (ugh, messy), OR make the commit under the name of the person merging the request.

The workflow below describes how to merge a pull request from the command line, with a single commit & attributing the work to the original author. Lets assume a branch of name `Smith_1995`.

First, from the master branch in the repo, run the following:

```
git merge --squash origin/Smith_1995
```

Then in R

```{r, eval=FALSE}
dataset_ids <- "Smith_1995"

# Update build file
build_setup_pipeline(method="base")

# check data builds
source(build.R) # to build all of the database

# or open the file build.R and run:

library(traits.build)
schema <- get_schema()
resource_metadata <- get_schema("config/metadata.yml", "metadata")
definitions <- get_schema("config/traits.yml", "traits")
unit_conversions <- get_unit_conversions("config/unit_conversions.csv")
taxon_list <- read_csv_char("config/taxon_list.csv")

# plus the three lines of code for the dataset you're adding

# run tests on dataset
austraits_run_tests()

# read and write yaml to prevent future reformatting
f <- file.path("data", dataset_ids, "metadata.yml")
read_metadata(f) %>% write_metadata(f)

# rebuild
source(build.R) # to build all of the database

# or open the file build.R and run the lines of code specified above
```

Now back in the terminal

```
git add .
git commit
```

Add a commit message, referencing relevant pull requests and issues, e.g.

```
Smith_1995: Import new data

For #224, closes #286
```

And finally, amend the commit author, to reference the person who did all the work!
```
git commit --amend --author "XXX <XXX@gmail.com>"
```

## Commit messages

Informative commit messages are ideal. Where possible, these should reference the issue being addressed. They should clearly describe the work done and value added to AusTraits in a few, clear, bulleted points.



## Version updating & Making a new release

Releases of the dataset are snapshots that are archived and available for use.

We use semantic versioning to label our versions. As discussed in [Falster et al 2019](http://doi.org/10.1093/gigascience/giz035), semantic versioning can apply to datasets as well as code.

The version number will have 3 components for actual releases, and 4 for development versions. The structure is `major.minor.patch.dev`, where `dev` is at least 9000.  The `dev` component provides a visual signal that this is a development version. So, if the current version is 0.9.1.9000, the release be 0.9.2, 0.10.0 or 1.0.0.

Our approach to incrementing version numbers is

- `major`: increment when you make changes to the structure that are likely incompatible with any code written to work with previous versions.
- `minor`: increment to communicate any changes to the structure that are likely to be compatible with any code written to work with the previous versions (i.e., allows code to run without error). Such changes might involve adding new data within the existing structure, so that the previous dataset version exists as a subset of the new version. For tabular data, this includes adding columns or rows. On the other hand, removing data should constitute a major version because records previously relied on may no longer exist.
- `patch`: Increment to communicate correction of errors in the actual data, without any changes to the structure. Such changes are unlikely to break or change analyses
written with the previous version in a substantial way.

<img src="figures/giz035fig2.png">

**Figure:** Semantic versioning communicates to users the types of changes that have occurred between successive versions of an evolving dataset, using a tri-digit label where increments in a number indicate major, minor, and patch-level changes, respectively. From [Falster et al 2019](http://doi.org/10.1093/gigascience/giz035), (CC-BY).

The process of making a release is as follows. Note that corresponding releases and versions are needed in both `austraits` and `traits.build`:

1. Update the version number in the DESCRIPTION file, using `

```{r, eval=FALSE}
desc::desc_bump_version()
```

2. Compile `traits.build`.

3. Update the documentation.

4. Commit and push to github.

5. Make a release on github, adding version number

5. Prepare for the next version by updating version numbers.

```{r, eval=FALSE}
desc::desc_bump_version("dev")
```

## Extracting data from PDF tables

If you encounter a PDF table of data and need to extract values, this can be achieved with the [`tabula-java` tool](https://github.com/tabulapdf/tabula-java/). There's actually an R wrapper (called [`tabulizer`](https://github.com/ropensci/tabulizer)), but we haven't succeeded in getting this running. However, it's easy enough to run the java tool at the command line on OSX.

1. [Download latest release of `tabula-java`](https://github.com/tabulapdf/tabula-java/releases) and save the file in your path

2. Run
```
java -jar tabula-1.0.3-jar-with-dependencies.jar my_table.pdf -o my_data.csv
```
This should output the data from the table in `my_table.pdf` into the csv `my_data.csv`

3. Clean up in Excel. check especially that the locations of white spaces are correct.